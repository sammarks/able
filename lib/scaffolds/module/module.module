<?php

use AbleCore\Modules\MenuManager;
use AbleCore\Modules\BlockManager;
use AbleCore\Modules\ThemeManager;

/**
 * Welcome to Able Core!
 *
 * This scaffold module was created by the Able Core CLI and serves as
 * an aid for introducing the Able Core module helpers. The code in this
 * file serves as an example for what is possible using the module
 * helpers.
 *
 * If this isn't your first fling, you're probably better off using
 * the empty scaffold (able scaffold:module --empty).
 *
 * If you're using this scaffold module in a production website, be sure
 * that you delete all the example code and comments as it's very messy
 * to have them in all of our production websites. Clean code is happy
 * code :)
 *
 * For more information about how each of these classes work, refer to
 * the comments within their functions or take a look at the documentation
 * setup at http://ablecore.ae-lin-dev-1.ableengine.com/
 *
 * If you have any questions, feel free to email Sam (smarks@ableengine.com),
 * or ask questions in the office.
 *
 * If you have a new feature that you'd like to add to the core, clone the
 * repository to your computer and add it! However, be sure to read through
 * the contributing notes before doing so (they can be found at the link
 * mentioned above).
 *
 * Enjoy!
 */

/**
 * About this File
 *
 * This file should only contain hook_menu(), hook_theme() and hook_block().
 * Any other utility functions should be included at the top of this file
 * (using require_once). By convention, these files should be inside a
 * "helpers" folder and should end in ".inc.php"
 *
 * These files should have hyphens in their name. As a convention, all
 * filenames should have hyphens and not underscores.
 *
 * An example of this is below:
 */
require_once "helpers/some-hook.inc.php";

function MODULE_menu()
{
	/**
	 * This is your hook_menu() function. Basically, this tells Drupal which
	 * URLs go to which functions in your module. hook_menu() is extremely
	 * flexible. Here are a few reasons why:
	 *
	 *  - Separates logic and display into two separate files.
	 *  - Allows callback functions to be introduced for the following
	 *    purposes:
	 *     - Setting the title of the page (title callback)
	 *     - Getting the content of the page (page callback)
	 *     - Checking permissions on the page (access callback)
	 *
	 * If you're curious about what hook_menu() has to offer, Google for something
	 * like "drupal hook_menu()" and click on the Drupal API result.
	 *
	 * Normally, hook_menu() accepts an array of configuration values.
	 * Unfortunately, if the module is large, this array can get quite messy.
	 * That's where MenuManager comes in! The primary goal of MenuManager is
	 * to make code for the hook_menu() function cleaner and easier to read.
	 * It does this by attempting to put every declaration on one line instead
	 * of three.
	 *
	 * Let's look at some examples!
	 */

	/**
	 * First, we have to start with a return statement. "Starting with a return
	 * statement?" you ask. Why, of course! We put the return statement at the
	 * top of the function because the entire function is a chain of calls to
	 * the MenuManager class. It's pretty, trust me.
	 */
	return MenuManager::init()

		/**
		 * This is the simplest way for declaring a menu item. The define function
		 * accepts three arguments (in its simplest form):
		 *
		 *  - path - This is the path for the menu item. Placeholders of any type
		 *    are denoted with %. You can put placeholders in any part of the
		 *    path you want.
		 *  - callback - This argument is a string in the format of file@function.
		 *    In this example, when viewing this page Drupal will look for
		 *    an action_testing function inside callbacks/file.php. Any arguments
		 *    mentioned in the path will be passed as arguments to the callback.
		 *    For example, if we have the path test/%/path/%, two arguments will
		 *    be passed to the callback. They are passed in the order that they
		 *    appear in the path.
		 *  - title - This is simply the title of the page. If you're using something
		 *    fancy like "title callback", this value is ignored.
		 */
		->define('test/path/%', 'file@testing', 'Test Path')

		/**
		 * Let's go even further! Let's say you want to have a function called to
		 * determine the title of a page. Simple.
		 *
		 * The fourth argument of the define() function is an array of extra
		 * configuration values. These values are merged into the main configuration
		 * before returning the array to send to Drupal.
		 *
		 * Let's say you have the path hello/world, and you want the title of
		 * that path to be the current unix timestamp. Here's how you would do it:
		 */
		->define('hello/world', 'file@date', 'Test Path', array(
			'title callback' => 'action_date_title'
		))

		/**
		 * Let's talk about a few conventions that are in place here.
		 *
		 *  - Filenames have hyphens only - Do not put underscores in the filename.
		 *    This is for consistency.
		 *  - Actions have underscores only - Since the action is prefixed with action_,
		 *    make sure your action only has an underscore. For example "test-file@test_action"
		 *    is correct while "test_file@test-action" is not.
		 *  - When creating a callback function for a title, only add "title callback"
		 *    to the extra configuration array. "title arguments" is required by Drupal, but is
		 *    automatically set to the same arguments passed to the main page callback.
		 *     - If you wish to override the arguments, simply create a "title arguments"
		 *       key in the extra configuration array.
		 */

		/**
		 * Now let's say you want to pass some default arguments to the callback.
		 *
		 * Let's say we have the path test/path2 and want to pass an argument of the
		 * value "world."
		 *
		 * This is where the fifth argument for the define() function comes in! The fifth
		 * argument is an array of default arguments to pass to the function. Anything
		 * added to this array is added after the arguments generated by the path. In this
		 * example, we don't have any arguments generated by the path.
		 */
		->define('test/path2', 'file@test_path_2', 'Test Path 2', array(), array(
			'world'
		))

		->fin();
}

function MODULE_theme()
{
	/**
	 * This is your hook_theme() function. This function tells Drupal core
	 * what theme hooks to register. Theme hooks contain all the HTML
	 * for a specific component. Typically, theme hooks are called using
	 * Drupal's theme() function with an array of variables to pass to the
	 * theme hook.
	 *
	 * Normally, theme hooks are defined in a massive array with all the
	 * configuration options. That's why the ThemeManager class was created.
	 * It's a solution, much like the MenuManager that lets us define theme
	 * hooks in one line instead of 5.
	 *
	 * There are two basic components to defining a theme: the key and the
	 * path to the template. Let's look at an example:
	 */

	/**
	 * First, you have to initialize the ThemeManager with the same return
	 * style as with the MenuManager.
	 */
	return ThemeManager::init()

		/**
		 * Here's our basic define() call again. The arguments to pass are
		 * pretty self-explanatory:
		 *
		 *  - key - This is how the theme is identified. If you set the key
		 *    to be 'test_theme', when calling theme(), you'll do it like this:
		 *    theme('test_theme', array());
		 *  - path - This is the path to the template file for the theme hook.
		 *    Able Core prefixes all themes with themes/ and uses a . as a directory
		 *    separator. Therefore, if you do something like 'testing.theme',
		 *    Able Core will look in <module root>/themes/testing/theme.tpl.php
		 *    for the HTML to render.
		 */
		->define('test_theme', 'testing.theme')

		/**
		 * Here's another example. This one employs some conventions used by
		 * the block manager.
		 *
		 * Let's use the block below as an example. It's called 'test_block'.
		 * When the automation functions look for a theme hook to render the
		 * contents of the block, they look for a theme that follows this
		 * pattern:
		 *
		 *  block.[block_name]
		 *
		 * Therefore, because our block is called 'test_block', it'll look
		 * for the following theme hook when rendering the block:
		 *
		 *  block.test_block
		 *
		 * Then, the 'block.test_block' theme hook looks for the HTML in the
		 * themes/testing/test-block.tpl.php file.
		 */
		->define('block.test_block', 'testing.test-block')

		/**
		 * Finally, call the fin() function when you're finished defining your
		 * theme hooks.
		 */
		->fin();

	/**
	 * One last thing...
	 *
	 * The ac_global module associates preprocess functions with each theme.
	 * Here's a fun tidbit about Drupal theme hooks! Have you worked with
	 * THEME_preprocess_page, THEME_preprocess_html or THEME_preprocess_node?
	 * Of course you have! page, html and node are actually names of theme
	 * hooks. The official definition of HOOK_preprocess is the following:
	 *
	 *  HOOK_preprocess_THEME_HOOK
	 *
	 * HOOK being the name of the module and THEME_HOOK being the key for
	 * the theme hook defined with ThemeManager.
	 *
	 * Normally, all of these preprocess functions go in one file, but Able
	 * Core has a better way! Why put all of these preprocess functions in one
	 * file when we can separate them out and make sure each file only has one
	 * purpose?
	 *
	 * Let's start with a simple example.
	 *
	 * You have a theme hook with the name 'test_theme_hook.' Able Core will look
	 * for the function 'MODULE_preprocess_test_theme_hook' in the file
	 * '<module root>/preprocessors/test-theme-hook.php'. If it can't find the file
	 * or the function, it won't do anything. If it finds the function and the file,
	 * it will call the function passing a $variables array as the first argument.
	 * If you want to pass variables to your theme hook, add them as keys to the
	 * $variables array (it's passed by reference).
	 *
	 * If you're confused, fear not! There's an example in this scaffold module
	 * with 'test_block' below.
	 *
	 * Let's look at a more complicated example.
	 *
	 * What if you want to nest your block logic into several different folders?
	 * What if you have several blocks having to do with the homepage, and several
	 * others having to do with another page? Don't fret! Able Core has a solution.
	 *
	 * You have a block called 'homepage.slideshow_area' to generate content for
	 * the homepage slideshow. In order for this block to work, you'd have the
	 * following theme declaration:
	 *
	 *  ->define('block.homepage.slideshow_area', 'path.to.slideshow-area')
	 *
	 * The preprocess hook for your theme would be in the following file:
	 *
	 *  <module root>/preprocessors/block/homepage/slideshow-area.php
	 *
	 * and have the following functions:
	 *
	 *  MODULE_preprocess_block_homepage_slideshow_area(&$variables) {}
	 *
	 * That's as complicated as it gets!
	 */
}

function MODULE_block_info()
{
	/**
	 * And now we have the block manager...
	 *
	 * The block manager works very much like the theme and menu managers.
	 * It's simply a shortcut for defining new blocks.
	 *
	 * We begin with the return statement, as usual.
	 */
	return BlockManager::init()

		/**
		 * And then we define a block with the define() function. Here's the
		 * argument order:
		 *
		 *  - key - The machine name for the block. Take a look at the "One
		 *    Last Thing..." section above for a more advanced example of
		 *    what you can use here.
		 *  - name - This is the human name of the block. This is displayed
		 *    in the Drupal administration interface.
		 *  - extra_config - Much like the menu manager, the final argument
		 *    is an array of extra configuration options. Take a look at
		 *    hook_block_info() in the Drupal API for a glimpse at what else
		 *    you can put here!
		 */
		->define('test_block', 'Test Block')

		/**
		 * As usual, call the fin() function once you're done defining
		 * your module's blocks.
		 */
		->fin();

	/**
	 * Don't forget to read the "One Last Thing..." section above for a more
	 * advanced example!
	 */
}
